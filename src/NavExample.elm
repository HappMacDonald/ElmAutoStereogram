module NavExample exposing (main)

{-| Simple example of a tab fragment navigation SPA :)
Actual layout done with Elm-UI instead of HTML.
-}

import Browser
import Browser.Navigation as Nav
import Element exposing (Element)
import Element.Background as Background
import Element.Font as Font
import Html exposing (Html)
import Json.Decode as Decode
import Url



-- PRIMARY DECLARATION


main : Program Decode.Value Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = LinkClicked
        }



-- HELPERS AND DEFINITIONS


type TabType
    = TabPlaintext
    | TabMarkdown
    | TabImage



-- MODEL


{-| The navKey is an opaque object that you keep in your model
to assist in controlling browser page loading and history behavior.

currentUrl is kept here to confirm when the URL has actually changed,
and when it hasn't, so that we don't have to alter the page layout when no
real change was made. This is also important to prevent loops.

tab just keeps track of which tab is active via a Tagged Union. :)

This model itself is also a tagged union just because
I try to tagged union all of the things.

-}
type Model
    = Model
        { navKey : Nav.Key
        , currentUrl : Url.Url
        , tab : TabType
        }



-- INIT


init : Decode.Value -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    tabChange
        (Model
            { navKey = navKey
            , currentUrl = url
            , tab = TabPlaintext
            }
        )
        url



-- UPDATE


{-| The only kinds of messages we're keeping track of
are the kinds generated by the Browser.application navigational actions.
-}
type Msg
    = LinkClicked Browser.UrlRequest
    | UrlChanged Url.Url


{-| Because I am using a tagged union to keep track of active tab,
this function simply maps fragment strings to union constructors.
-}
fragmentTabMap : Maybe String -> TabType
fragmentTabMap fragment =
    case fragment of
        Just "TabMarkdown" ->
            TabMarkdown

        Just "TabImage" ->
            TabImage

        _ ->
            -- including Nothing and Just TabPlaintext
            TabPlaintext


{-| And then this function maps tabs to their descriptions
-}
tabDescriptionMap : TabType -> String
tabDescriptionMap tab =
    case tab of
        TabPlaintext ->
            "Plain Text"

        TabMarkdown ->
            "Reddit Markdown"

        TabImage ->
            "Downloadable Image"


{-| Both init and update need to update the model and issue a command
via the same logic, so this has been abstracted into the function tabChange.

We issue a Nav.load command if the URL is different than our model records,
and Cmd.none otherwise. This prevents any possible loop where might otherwise
try to issue a Nav.load command to reload the page you just got to.

-}
tabChange : Model -> Url.Url -> ( Model, Cmd Msg )
tabChange ((Model modelRecord) as model) url =
    let
        command =
            if modelRecord.currentUrl == url then
                Cmd.none

            else
                Nav.load (Url.toString url)
    in
    ( Model
        { modelRecord
            | tab = fragmentTabMap url.fragment
            , currentUrl = url
        }
    , command
    )


{-| This update function strategy just blatently stolen from the example
at the end of the elm/browser/1.0.1/Browser docs: <http://archive.is/ERrV2>
-}
update : Msg -> Model -> ( Model, Cmd Msg )
update msg ((Model modelRecord) as model) =
    case msg of
        LinkClicked urlRequest ->
            case urlRequest of
                Browser.Internal url ->
                    ( model
                    , Nav.pushUrl modelRecord.navKey (Url.toString url)
                    )

                Browser.External url ->
                    ( model, Nav.load url )

        UrlChanged url ->
            tabChange model url



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


{-| Just defining some colors
-}
tabColor : Element.Color
tabColor =
    Element.rgb 0.9 0.8 0.7


tabColorActive : Element.Color
tabColorActive =
    Element.rgb 0.8 0.7 0.6


{-| Helper function to actually render a tab
-}
tabRender : Model -> TabType -> String -> Element Msg
tabRender (Model model) tabTarget link =
    let
        title =
            tabDescriptionMap tabTarget

        backgroundColor =
            if tabTarget == model.tab then
                tabColorActive

            else
                tabColor
    in
    Element.link []
        { url = link
        , label = Element.text title
        }
        |> Element.el
            [ Background.color backgroundColor
            , Element.paddingXY 5 3

            -- , Element.explain Debug.todo
            ]


body : Model -> List (Html Msg)
body ((Model modelRecord) as model) =
    [ Element.layout
        [ Element.width Element.fill
        , Element.padding 20
        ]
      <|
        Element.column
            [ Element.centerX
            ]
            [ Element.row
                [ Element.spacing 30
                ]
                [ tabRender model TabPlaintext "#TabPlaintext"
                , tabRender model TabMarkdown "#TabMarkdown"
                , tabRender model TabImage "#TabImage"
                ]
            , Element.el
                [ Background.color tabColorActive
                , Element.padding 5
                , Element.width Element.fill
                , Font.center
                ]
                (tabDescriptionMap modelRecord.tab
                    |> Element.text
                )
            ]
    ]


view : Model -> Browser.Document Msg
view model =
    { title = "NavExample"
    , body = body model
    }
